// -*- mode:c++ -*-

//Copyright (c) 2003, 2004, 2005
//The Regents of The University of Michigan
//All Rights Reserved

//This code is part of the M5 simulator.

//Permission is granted to use, copy, create derivative works and
//redistribute this software and such derivative works for any purpose,
//so long as the copyright notice above, this grant of permission, and
//the disclaimer below appear in all copies made; and so long as the
//name of The University of Michigan is not used in any advertising or
//publicity pertaining to the use or distribution of this software
//without specific, written prior authorization.

//THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION FROM THE
//UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY PURPOSE, AND WITHOUT
//WARRANTY BY THE UNIVERSITY OF MICHIGAN OF ANY KIND, EITHER EXPRESS OR
//IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF
//MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE REGENTS OF
//THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE FOR ANY DAMAGES,
//INCLUDING DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
//DAMAGES, WITH RESPECT TO ANY CLAIM ARISING OUT OF OR IN CONNECTION
//WITH THE USE OF THE SOFTWARE, EVEN IF IT HAS BEEN OR IS HEREAFTER
//ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

//Authors: Steven K. Reinhardt

////////////////////////////////////////////////////////////////////
//
// Utility functions for execute methods
//

output exec {{

    /// Return opa + opb, summing carry into third arg.
    inline uint64_t
    addc(uint64_t opa, uint64_t opb, int &carry)
    {
        uint64_t res = opa + opb;
        if (res < opa || res < opb)
            ++carry;
        return res;
    }

    /// Multiply two 64-bit values (opa * opb), returning the 128-bit
    /// product in res_hi and res_lo.
    inline void
    mul128(uint64_t opa, uint64_t opb, uint64_t &res_hi, uint64_t &res_lo)
    {
        // do a 64x64 --> 128 multiply using four 32x32 --> 64 multiplies
        uint64_t opa_hi = opa<63:32>;
        uint64_t opa_lo = opa<31:0>;
        uint64_t opb_hi = opb<63:32>;
        uint64_t opb_lo = opb<31:0>;

        res_lo = opa_lo * opb_lo;

        // The middle partial products logically belong in bit
        // positions 95 to 32.  Thus the lower 32 bits of each product
        // sum into the upper 32 bits of the low result, while the
        // upper 32 sum into the low 32 bits of the upper result.
        uint64_t partial1 = opa_hi * opb_lo;
        uint64_t partial2 = opa_lo * opb_hi;

        uint64_t partial1_lo = partial1<31:0> << 32;
        uint64_t partial1_hi = partial1<63:32>;
        uint64_t partial2_lo = partial2<31:0> << 32;
        uint64_t partial2_hi = partial2<63:32>;

        // Add partial1_lo and partial2_lo to res_lo, keeping track
        // of any carries out
        int carry_out = 0;
        res_lo = addc(partial1_lo, res_lo, carry_out);
        res_lo = addc(partial2_lo, res_lo, carry_out);

        // Now calculate the high 64 bits...
        res_hi = (opa_hi * opb_hi) + partial1_hi + partial2_hi + carry_out;
    }

    /// Map 8-bit S-floating exponent to 11-bit T-floating exponent.
    /// See Table 2-2 of Alpha AHB.
    inline int
    map_s(int old_exp)
    {
        int hibit = old_exp<7:>;
        int lobits = old_exp<6:0>;

        if (hibit == 1) {
            return (lobits == 0x7f) ? 0x7ff : (0x400 | lobits);
        }
        else {
            return (lobits == 0) ? 0 : (0x380 | lobits);
        }
    }

    /// Convert a 32-bit S-floating value to the equivalent 64-bit
    /// representation to be stored in an FP reg.
    inline uint64_t
    s_to_t(uint32_t s_val)
    {
        uint64_t tmp = s_val;
        return (tmp<31:> << 63 // sign bit
                | (uint64_t)map_s(tmp<30:23>) << 52 // exponent
                | tmp<22:0> << 29); // fraction
    }

    /// Convert a 64-bit T-floating value to the equivalent 32-bit
    /// S-floating representation to be stored in memory.
    inline int32_t
    t_to_s(uint64_t t_val)
    {
        return (t_val<63:62> << 30   // sign bit & hi exp bit
                | t_val<58:29>);     // rest of exp & fraction
    }
}};

