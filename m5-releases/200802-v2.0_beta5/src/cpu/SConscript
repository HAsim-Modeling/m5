# -*- mode:python -*-

# Copyright (c) 2006
# The Regents of The University of Michigan
# All Rights Reserved
#
# This code is part of the M5 simulator.
#
# Permission is granted to use, copy, create derivative works and
# redistribute this software and such derivative works for any
# purpose, so long as the copyright notice above, this grant of
# permission, and the disclaimer below appear in all copies made; and
# so long as the name of The University of Michigan is not used in any
# advertising or publicity pertaining to the use or distribution of
# this software without specific, written prior authorization.
#
# THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION FROM THE
# UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY PURPOSE, AND
# WITHOUT WARRANTY BY THE UNIVERSITY OF MICHIGAN OF ANY KIND, EITHER
# EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE. THE REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE
# LIABLE FOR ANY DAMAGES, INCLUDING DIRECT, SPECIAL, INDIRECT,
# INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM
# ARISING OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN
# IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGES.
#
# Authors: Steven K. Reinhardt

Import('*')

#################################################################
#
# Generate StaticInst execute() method signatures.
#
# There must be one signature for each CPU model compiled in.
# Since the set of compiled-in models is flexible, we generate a
# header containing the appropriate set of signatures on the fly.
#
#################################################################

# CPU model-specific data is contained in cpu_models.py
# Convert to SCons File node to get path handling
models_db = File('cpu_models.py')
# slurp in contents of file
execfile(models_db.srcnode().abspath)

# Template for execute() signature.
exec_sig_template = '''
virtual Fault execute(%s *xc, Trace::InstRecord *traceData) const = 0;
virtual Fault initiateAcc(%s *xc, Trace::InstRecord *traceData) const
{ panic("initiateAcc not defined!"); M5_DUMMY_RETURN };
virtual Fault completeAcc(Packet *pkt, %s *xc,
                          Trace::InstRecord *traceData) const
{ panic("completeAcc not defined!"); M5_DUMMY_RETURN };
'''

mem_ini_sig_template = '''
virtual Fault initiateAcc(%s *xc, Trace::InstRecord *traceData) const { panic("Not defined!"); M5_DUMMY_RETURN };
'''

mem_comp_sig_template = '''
virtual Fault completeAcc(uint8_t *data, %s *xc, Trace::InstRecord *traceData) const { panic("Not defined!"); return NoFault; M5_DUMMY_RETURN };
'''

# Generate a temporary CPU list, including the CheckerCPU if
# it's enabled.  This isn't used for anything else other than StaticInst
# headers.
temp_cpu_list = env['CPU_MODELS'][:]

if env['USE_CHECKER']:
    temp_cpu_list.append('CheckerCPU')

# Generate header.
def gen_cpu_exec_signatures(target, source, env):
    f = open(str(target[0]), 'w')
    print >> f, '''
#ifndef __CPU_STATIC_INST_EXEC_SIGS_HH__
#define __CPU_STATIC_INST_EXEC_SIGS_HH__
'''
    for cpu in temp_cpu_list:
        xc_type = CpuModel.dict[cpu].strings['CPU_exec_context']
        print >> f, exec_sig_template % (xc_type, xc_type, xc_type)
    print >> f, '''
#endif  // __CPU_STATIC_INST_EXEC_SIGS_HH__
'''

# Generate string that gets printed when header is rebuilt
def gen_sigs_string(target, source, env):
    return "Generating static_inst_exec_sigs.hh: " \
           + ', '.join(temp_cpu_list)

# Add command to generate header to environment.
env.Command('static_inst_exec_sigs.hh', models_db,
            Action(gen_cpu_exec_signatures, gen_sigs_string,
                   varlist = temp_cpu_list))

env.Depends('static_inst_exec_sigs.hh', Value(env['USE_CHECKER']))
env.Depends('static_inst_exec_sigs.hh', Value(env['CPU_MODELS']))

# List of suppported CPUs by the Checker.  Errors out if USE_CHECKER=True
# and one of these are not being used.
CheckerSupportedCPUList = ['O3CPU', 'OzoneCPU']

SimObject('BaseCPU.py')
SimObject('FuncUnit.py')
SimObject('ExeTracer.py')
SimObject('IntelTrace.py')

Source('activity.cc')
Source('base.cc')
Source('cpuevent.cc')
Source('exetrace.cc')
Source('func_unit.cc')
Source('inteltrace.cc')
Source('pc_event.cc')
Source('quiesce_event.cc')
Source('static_inst.cc')
Source('simple_thread.cc')
Source('thread_context.cc')
Source('thread_state.cc')

if env['FULL_SYSTEM']:
    SimObject('IntrControl.py')

    Source('intr_control.cc')
    Source('profile.cc')

    if env['TARGET_ISA'] == 'sparc':
        SimObject('LegionTrace.py')
        Source('legiontrace.cc')

if env['USE_CHECKER']:
    Source('checker/cpu.cc')
    TraceFlag('Checker')
    checker_supports = False
    for i in CheckerSupportedCPUList:
        if i in env['CPU_MODELS']:
            checker_supports = True
    if not checker_supports:
        print "Checker only supports CPU models",
        for i in CheckerSupportedCPUList:
            print i,
        print ", please set USE_CHECKER=False or use one of those CPU models"
        Exit(1)

TraceFlag('Activity')
TraceFlag('Commit')
TraceFlag('Context')
TraceFlag('Decode')
TraceFlag('DynInst')
TraceFlag('ExecEnable')
TraceFlag('ExecCPSeq')
TraceFlag('ExecEffAddr')
TraceFlag('ExecFetchSeq')
TraceFlag('ExecOpClass')
TraceFlag('ExecRegDelta')
TraceFlag('ExecResult')
TraceFlag('ExecSpeculative')
TraceFlag('ExecSymbol')
TraceFlag('ExecThread')
TraceFlag('ExecTicks')
TraceFlag('Fetch')
TraceFlag('IntrControl')
TraceFlag('PCEvent')
TraceFlag('Quiesce')

CompoundFlag('Exec', [ 'ExecEnable', 'ExecTicks', 'ExecOpClass', 'ExecThread',
    'ExecEffAddr', 'ExecResult', 'ExecSymbol' ])
