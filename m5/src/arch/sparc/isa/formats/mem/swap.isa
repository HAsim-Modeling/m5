
//This template provides the execute functions for a swap
def template SwapExecute {{
        Fault %(class_name)s::execute(%(CPU_exec_context)s *xc,
                Trace::InstRecord *traceData) const
        {
            Fault fault = NoFault;
            //This is to support the conditional store in cas instructions.
            //It should be optomized out in all the others
            bool storeCond = true;
            Addr EA;
            %(fp_enable_check)s;
            %(op_decl)s;
            uint64_t mem_data = 0;

            %(op_rd)s;
            %(ea_code)s;
            DPRINTF(Sparc, "%s: The address is 0x%x\n", mnemonic, EA);
            %(fault_check)s;
            if(fault == NoFault)
            {
                %(code)s;
            }
            if(storeCond && fault == NoFault)
            {
                %(EA_trunc)s
                fault = xc->write((uint%(mem_acc_size)s_t)Mem,
                        EA, %(asi_val)s, &mem_data);
            }
            if(fault == NoFault)
            {
                    //Handle the swapping
                    %(postacc_code)s;
            }
            if(fault == NoFault)
            {
                    //Write the resulting state to the execution context
                    %(op_wb)s;
            }

            return fault;
        }
}};


def template SwapInitiateAcc {{
        Fault %(class_name)s::initiateAcc(%(CPU_exec_context)s * xc,
                Trace::InstRecord * traceData) const
        {
            Fault fault = NoFault;
            Addr EA;
            %(fp_enable_check)s;
            uint64_t mem_data = 0;
            %(op_decl)s;
            %(op_rd)s;
            %(ea_code)s;

            DPRINTF(Sparc, "%s: The address is 0x%x\n", mnemonic, EA);
            %(fault_check)s;

            if(fault == NoFault)
            {
                %(code)s;
            }
            if(fault == NoFault)
            {
                %(EA_trunc)s
                fault = xc->write((uint%(mem_acc_size)s_t)Mem,
                        EA, %(asi_val)s, &mem_data);
            }
            return fault;
        }
}};



def template SwapCompleteAcc {{
        Fault %(class_name)s::completeAcc(PacketPtr pkt, %(CPU_exec_context)s * xc,
                Trace::InstRecord * traceData) const
        {
            Fault fault = NoFault;
            %(op_decl)s;

            uint64_t mem_data = pkt->get<uint%(mem_acc_size)s_t>();

            if(fault == NoFault)
            {
                    //Handle the swapping
                    %(postacc_code)s;
            }
            if(fault == NoFault)
            {
                    //Write the resulting state to the execution context
                    %(op_wb)s;
            }

            return fault;
        }
}};

let {{
    SwapFuncs = [SwapExecute, SwapInitiateAcc, SwapCompleteAcc]
}};


def format Swap(code, postacc_code, mem_flags, *opt_flags) {{
    mem_flags = makeList(mem_flags)
    flags = string.join(mem_flags, '|')

    (header_output,
     decoder_output,
     exec_output,
     decode_block) = doMemFormat(code, SwapFuncs, '', name, Name, flags,
         ["IsStoreConditional"], postacc_code)
}};

def format SwapAlt(code, postacc_code, mem_flags, *opt_flags) {{
    mem_flags = makeList(mem_flags)
    mem_flags.append("EXT_ASI")
    flags = string.join(mem_flags, '|')
    (header_output,
     decoder_output,
     exec_output,
     decode_block) = doMemFormat(code, SwapFuncs, AlternateASIPrivFaultCheck,
         name, Name, flags, ["IsStoreConditional"], postacc_code)
}};


let {{
    def doCasFormat(code, execute, faultCode, name, Name, mem_flags, opt_flags, postacc_code = ''):
        addrCalcReg = 'EA = Rs1;'
        iop = InstObjParams(name, Name, 'Mem',
                {"code": code, "postacc_code" : postacc_code,
                 "fault_check": faultCode, "ea_code": addrCalcReg,
                 "EA_trunc" : TruncateEA}, opt_flags)
        header_output = MemDeclare.subst(iop)
        decoder_output = BasicConstructor.subst(iop)
        decode_block = BasicDecode.subst(iop)
        microParams = {"code": code, "postacc_code" : postacc_code,
            "ea_code" : addrCalcReg, "fault_check" : faultCode,
            "EA_trunc" : TruncateEA}
        exec_output = doSplitExecute(execute, name, Name, mem_flags,
                ["IsStoreConditional"], microParams);
        return (header_output, decoder_output, exec_output, decode_block)
}};


def format CasAlt(code, postacc_code, mem_flags, *opt_flags) {{
    mem_flags = makeList(mem_flags)
    mem_flags.append("EXT_ASI")
    flags = string.join(mem_flags, '|')
    (header_output,
     decoder_output,
     exec_output,
     decode_block) = doCasFormat(code, SwapFuncs, AlternateASIPrivFaultCheck,
         name, Name, flags, ["IsStoreConditional"], postacc_code)
}};


